<!doctype html>
<html lang="en">
<head>
    <title>3D Model Editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel=stylesheet href="css/base.css"/>
    <script>
                    var fileName;
                    var filename;
                    var fileType;
                    function func()
                    {
                    fileName = document.getElementById("fileinput").files[0].name;
                    filename = fileName.replace(/^.*\\/, "");
                    }
                    function func1()
                    {
                    document.getElementById("hidden").value = filename;
                    }
        </script>
</head>

<body>
<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Scene.js"></script>
<script src="js/Geometry.js"></script>
<script src="js/GeometryUtils.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/STLLoader.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/jquery-2.1.0.min.js"></script>
<script src="js/FileSaver.js"></script>

<div id="ThreeJS" style="z-index: 1; position: relative; left:0px; top:5px"></div>
<div style="position: absolute; left: 900px; top: 0px">
    X=<input type="text" id="xvalue" size="4"/> 
    Y=<input type="text" id="yvalue" size="4"/> 
    Z=<input type="text" id="zvalue" size="4"/><br>
    <input type="radio" name="modelEdit" id="move" onclick="move()"><label for="move">Move</label>          
    <input type="radio" name="modelEdit" id="scale" onclick="scale()"><label for="scale">Scale</label>
    <input type="radio" name="modelEdit" id="rotate" onclick="rotate()"><label for="rotate">Rotate</label><br/> 
    <input type="text" id="extrVal" size="4"/><button onclick="extrude()"> Extrude </button><br>
    <button onclick="saveSTL()">Download</button>
    <button onclick="reset()"> Reset </button>
</div>
<script>

// MAIN

// standard global variables
var container,projector, scene,loader, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();

// custom global variables
var geometry = new THREE.Geometry();
var targetList =[],intersects = [];
var mouse = { x: 0, y: 0 };
var indexFaceArr = [],intNormal, planeSelect = []; 
var totalFaceCount = 0,totalVertexCount = 0;
var mouseSphere=[];

init();
render();

// FUNCTIONS 		
function init() 
{
    // SCENE
    scene = new THREE.Scene();
        
    // CAMERA 
    var SCREEN_WIDTH = 800, SCREEN_HEIGHT = 600;
    var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
    scene.add(camera);
    camera.position.set(700,500,500);
    camera.lookAt(scene.position);	
    
    // RENDERER
    if ( Detector.webgl )
    	renderer = new THREE.WebGLRenderer( {antialias:true} );
    else
    	renderer = new THREE.CanvasRenderer(); 
    renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
    container = document.getElementById( 'ThreeJS' );
    container.appendChild( renderer.domElement );
    
    // EVENTSx
    THREEx.FullScreen.bindKey({ charCode : 'f'.charCodeAt(0) });
	
    // CONTROLS
    controls = new THREE.OrbitControls( camera, renderer.domElement );
        
    // LIGHT
    var light = new THREE.HemisphereLight(0x777777);
    scene.add(light);

    // AXES
    var axes = new THREE.AxisHelper(100);
    axes.position.set(0,0,0);
    scene.add(axes);
    
    ////////////
    //STL Load//
    ////////////
    addMesh();
    
    // initialize object to perform world/screen calculations
    projector = new THREE.Projector();

    // when the mouse moves, call the given function
    container.addEventListener( 'mousedown', onDocumentMouseDown, false );
    //container.addEventListener( 'mousemove', onDocumentMouseMove, false );

    // STATS BOX//
    stats = document.createElement("div");
    stats.id = "statistics";
    stats.style.cssText = "position:absolute; width:100px; height:50px; text-align: left; left:10px; top:10px; font:12px Courier New; color:red; background:transparent;";
    container.appendChild( stats );
}

// Adds new meshes to the scene; also used for reset function
function addMesh()
{
    loader = new THREE.STLLoader();
    loader.addEventListener( 'load', function ( event ) {
    geometry = event.content;
    geometry.mergeVertices();
    
    newMesh(geometry);
    
    totalFaceCount = geometry.faces.length;
    totalVertexCount = geometry.vertices.length;
    stats.innerHTML = totalVertexCount.toString() + ' vertices' + '<br/>' + totalFaceCount.toString() + ' facets';
    });
    loader.load('Model/3110.stl');
}

function newMesh(geom)
{
    mesh = new THREE.Mesh( geom, new THREE.MeshLambertMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } ));
    scene.add(mesh);
    wireMesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true }));
    mesh.add( wireMesh );
    targetList.push(mesh);
}
/*
function onDocumentMouseMove( event ) 
{
    mouse.x = ( event.clientX / 400 ) * 2 - 1;
    mouse.y = - ( event.clientY / 300 ) * 2 + 1;
}
*/
function onDocumentMouseDown( event )
{
    console.log("Click.");
    mouse.x = ( event.clientX / 800  ) * 2 - 1;
    mouse.y = - ( event.clientY / 600 ) * 2 + 1;
    checkSelection();
 }

// Checking faces for selection and highlighting them
function checkSelection()
{ 
    //test items in selected faces array
    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
    projector.unprojectVector( vector, camera );
    var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
    
    intersects = ray.intersectObjects( targetList );
    if ( intersects.length > 0 )
    {
        console.log("Hit @ " + toString( intersects[0].point ) );
        intNormal = intersects[0].face.normal;
        
        indexFaceArr= [];
        for(var i=0; i< geometry.faces.length; i++)
        {
            if( compare(geometry.faces[i].normal, intNormal))
            {
                if(intersects[0].faceIndex !== i)
                indexFaceArr.push(i);
            }
        }
        planeSelect = plane(intersects[0].face, indexFaceArr);
        planeSelect.push(intersects[0].faceIndex);
        updateColor(planeSelect);
    }
}

// Updates plane colors 
function updateColor(indexArr){
    if(indexArr.length > 0){
    	for(var i=0; i< indexArr.length; i++){
        	geometry.faces[indexArr[i]].color.setRGB(1,0,0);
    	}
    }
    else{
    	for (var i =0 ; i < geometry.faces.length; i++){
    		geometry.faces[i].color.setRGB(1,1,1);
    	}
    }
    update();
}

// Extract intital plane from intersecting face
function plane(intFace, newFaceArr){
    var count = 0;
	var match1V = [], match0V = [];
    for(var n=0; n< newFaceArr.length; n++){
        count = 0;
		count = compareFaces(intFace, geometry.faces[ newFaceArr[n] ]);
        if(count === 0)
        {
            match0V.push(newFaceArr[n]);
        }
        else if(count > 0)
        {
            match1V.push(newFaceArr[n]);
        }
    }
    match1V = planeExtrapolate(match1V,match0V);
    return match1V;
}

// Extrapolate initial plane to find all triangles in a single plane
function planeExtrapolate(match1,match0){
    var i = 0, count2 = 0;
    while(i < match0.length){
    for(var j=0; j< match1.length; j++){
        count2 += compareFaces( geometry.faces[ match1[j]], geometry.faces[ match0[i]] );
    }
    if( count2 > 0)
    {
        var temp = match0[i];
	match0.splice(i,1);
	match1.push( temp);
    }	
    else
        i++;
    }
    return match1;
}

////////////////////////////////////////////////////////////////////////////////
//ALL EDITING FUNCTIONS//
////////////////////////////////////////////////////////////////////////////////

function scale(){
    var Sx = parseFloat(document.getElementById('xvalue').value);
    var Sy = parseFloat(document.getElementById('yvalue').value);
    var Sz = parseFloat(document.getElementById('zvalue').value);
    if (isNaN(Sx)){Sx = 1;} if (isNaN(Sy)){Sy = 1;} if (isNaN(Sz)){Sz = 1;}	
    mesh.scale.set(Sx,Sy,Sz);
}

function move(){
    var Mx = parseFloat(document.getElementById('xvalue').value);
    var My = parseFloat(document.getElementById('yvalue').value);
    var Mz = parseFloat(document.getElementById('zvalue').value);
    if (isNaN(Mx)){Mx = 0;} if (isNaN(My)){My = 0;} if (isNaN(Mz)){Mz = 0;}	
    mesh.position.x += Mx;
    mesh.position.y += My;
    mesh.position.z += Mz;
}

function rotate(){
    pi = Math.PI;
    var Ax = pi * (parseFloat(document.getElementById('xvalue').value) / 180);
    var Ay = pi * (parseFloat(document.getElementById('yvalue').value) / 180);
    var Az = pi * (parseFloat(document.getElementById('zvalue').value) / 180);
    if (isNaN(Ax)){Ax = 0;} if (isNaN(Ay)){Ay = 0;} if (isNaN(Az)){Az = 0;}
    mesh.rotation.x += Ax;
    mesh.rotation.y += Ay;
    mesh.rotation.z += Az;
}

function extrude(){
    if(intersects.length > 0)
    {
        var val = parseFloat(document.getElementById('extrVal').value);
        var vertArr = [];
        for(var i=0; i<planeSelect.length; i++){
            vertArr.push(geometry.faces[planeSelect[i]].a);
            vertArr.push(geometry.faces[planeSelect[i]].b);
            vertArr.push(geometry.faces[planeSelect[i]].c);
        }
        vertArr = vertArr.getUnique();
        vertArr.sort(function(a, b){return a - b});
        for(var i=0; i<vertArr.length; i++){
            geometry.vertices[vertArr[i]].x += val * intNormal.x;
            geometry.vertices[vertArr[i]].y += val * intNormal.y;
            geometry.vertices[vertArr[i]].z += val * intNormal.z;
        }
    }
    else
    {
        alert('Please select a plane!!');
    }
    update(); 
}

function setOrigin(){
    mesh.position.set(0,0,0);
}

function reset(){
    if(intersects.length > 0){
    	intersects = []; 
    }
    planeSelect = [];
    updateColor(planeSelect);
    scene.remove(mesh);
    addMesh();
}

////////////////////////////////////////////////////////////////////////////////
// AUXILLARY FUNCTIONS //
////////////////////////////////////////////////////////////////////////////////

function compare(vec1, vec2){
    if(vec1.x === vec2.x && vec1.y === vec2.y && vec1.z === vec2.z)
        return true;
    else
        return false;
}

function compareFaces(face1, face2){
    var key = ['a', 'b', 'c'],cnt = 0; 
	for(var i=0; i<3; i++){
		for(var j=0; j< 3; j++){
			if( face1[key[i]] === face2[key[j]] )
				cnt++;
		}
    }
	return cnt;
}

function toString(v) { return "[ " + v.x + ", " + v.y + ", " + v.z + " ]"; }

function render() 
{
    requestAnimationFrame( render );
    renderer.render( scene, camera );		
    update();
}

function update()
{
    geometry.verticesNeedUpdate = true;
    geometry.elementsNeedUpdate = true;
    geometry.colorsNeedUpdate = true;
    controls.update();
}

// Return unique values inside array
Array.prototype.getUnique = function(){
    var u = {}, a = [];
    for (var i = 0, l = this.length; i < l; ++i){
        if (u.hasOwnProperty(this[i])) {
            continue;
	}
	a.push(this[i]);
	u[this[i]] = 1;
    }
    return a;
};

////////////////////////////////////////////////////////////////////////////////
// SAVE STL FILE //
////////////////////////////////////////////////////////////////////////////////

function stringifyVertex(vec){
  return "vertex "+vec.x+" "+vec.y+" "+vec.z+" \n";
}
 
// Given a THREE.Geometry, create an STL string
function generateSTL(geo){
  var vertices = geo.vertices;
  var tris     = geo.faces;
 
  var stl = "solid pixel";
  for(var i = 0; i<tris.length; i++){
    stl += ("facet normal "+stringifyVertex( tris[i].normal )+" \n");
    stl += ("outer loop \n");
    stl += stringifyVertex( vertices[ tris[i].a ]);
    stl += stringifyVertex( vertices[ tris[i].b ]);
    stl += stringifyVertex( vertices[ tris[i].c ]);
    stl += ("endloop \n");
    stl += ("endfacet \n");
  }
  stl += ("endsolid");
 
  return stl;
}
 
// Use FileSaver.js 'saveAs' function to save the string
function saveSTL( ){  
  var stlString = generateSTL( geometry );
  
  var blob = new Blob([stlString], {type: 'text/plain'});
  
  saveAs(blob, name + 'CHACHA.stl');
  
}
</script>

</body>
</html>
