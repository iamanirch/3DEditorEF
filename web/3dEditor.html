<!doctype html>
<html lang="en">
<head>
    <title>3D Model Editor</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel=stylesheet href="css/base.css"/>
    
</head>

<body>
<script src="js/Three.js"></script>
<script src="js/Detector.js"></script>
<script src="js/Scene.js"></script>
<script src="js/Geometry.js"></script>
<script src="js/GeometryUtils.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/STLLoader.js"></script>
<script src="js/FileSaver.js"></script>
<script src="js/THREEx.KeyboardState.js"></script>
<script src="js/THREEx.FullScreen.js"></script>
<script src="js/THREEx.WindowResize.js"></script>
<script src="js/jquery-2.1.0.min.js"></script>

<div id="ThreeJS" style="z-index: 1; position: absolute; left:0px; top:0px"></div>
<div id="editBox" style="position: relative; top:300px"> 
    X<input type="text" id="xscale_value" size="4"/>
    Y<input type="text" id="yscale_value" size="4"/>
    Z<input type="text" id="zscale_value" size="4"/> <button onclick="Scale()"> Scale </button><br>
    X<input type="text" id="xrot_value" size="4"/>
    Y<input type="text" id="yrot_value" size="4"/>
    Z<input type="text" id="zrot_value" size="4"/> <button onclick="Rotate()"> Rotate </button><br>
    X<input type="text" id="xmove_value" size="4"/>
    Y<input type="text" id="ymove_value" size="4"/>
    Z<input type="text" id="zmove_value" size="4"/> <button onclick="Move()"> Move </button><br>
    <input type="text" id="extrVal" size="4"/> <button onclick="Extrude()"> Extrude </button>  <br>
    <button onclick="Reset()"> Reset </button> <button onclick="setOrigin()"> Set Origin </button><br>
    <button onclick="saveSTL()"> Download </button>
</div>
<script>

// MAIN

// standard global variables
var container, scene,loader, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

// custom global variables
var targetList =[],intersects = [];
var geometry = new THREE.Geometry();
var geometryOrig;
var projector,mouse = { x: 0, y: 0 };
var indexFaceArr = [],intNormal; 
var totalFaceCount = 0,totalVertexCount = 0;
var selectedFaces = [], INTERSECTED;
var baseColor=new THREE.Color( 0xffffff );
var highlightedColor=new THREE.Color( 0x00ff00 );
var selectedColor=new THREE.Color( 0xff0000 );
var mouseSphereCoords = null;
var mouseSphere=[];
var planeSelect = [];

init();
render();

// FUNCTIONS 		
function init() 
{
	// SCENE
	scene = new THREE.Scene();
        
    // CAMERA 
	var SCREEN_WIDTH = 400, SCREEN_HEIGHT =300;
	var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
	camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
	scene.add(camera);
	camera.position.set(700,500,500);
	camera.lookAt(scene.position);	
        
	// RENDERER
	if ( Detector.webgl )
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	else
		renderer = new THREE.CanvasRenderer(); 

	renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
	container = document.getElementById( 'ThreeJS' );
	container.appendChild( renderer.domElement );
	
    // EVENTSx
	THREEx.FullScreen.bindKey({ charCode : 'f'.charCodeAt(0) });
	
    // CONTROLS
	controls = new THREE.OrbitControls( camera, renderer.domElement );
        
	// LIGHT
	var light = new THREE.HemisphereLight(0x777777);
	scene.add(light);

	// AXES
	var axes = new THREE.AxisHelper(100);
	axes.position.set(0,0,0);
	scene.add(axes);

	////////////
	//STL Load//
	////////////
	addMesh();

	// SPHERE
	var newSphereGeom= new THREE.SphereGeometry(5,5,5);
	var sphere= new THREE.Mesh(newSphereGeom, new THREE.MeshLambertMaterial({ color: 0x2266dd }));
	scene.add(sphere);
	mouseSphere.push(sphere);
	
	//////////////////////////////////////////////////////////////////////
	
	// initialize object to perform world/screen calculations
	projector = new THREE.Projector();

	// when the mouse moves, call the given function
    container.addEventListener( 'mousedown', onDocumentMouseDown, false );
    container.addEventListener( 'mousemove', onDocumentMouseMove, false );

	// STATS //
	stats = document.createElement("div");
	stats.id = "statistics";
	stats.style.cssText = "position:absolute; width:100px; height:50px; text-align: left; left:10px; top:10px; font:12px Courier New; color:red; background:transparent;"
	container.appendChild( stats );
}

function addMesh(){
    loader = new THREE.STLLoader();
    loader.addEventListener( 'load', function ( event ) {
    geometry = event.content;
    geometry.mergeVertices();
    newMesh(geometry);

    geometryOrig = geometry.vertices.slice(0); console.log(geometryOrig);
    totalFaceCount = geometry.faces.length;
    totalVertexCount = geometry.vertices.length;
    stats.innerHTML = totalVertexCount.toString() + ' vertices' + '<br/>' + totalFaceCount.toString() + ' facets';
    });
    loader.load('Model/1004.STL');
}

function newMesh(geom){
    mesh = new THREE.Mesh( geom, new THREE.MeshLambertMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } ));
    scene.add(mesh);
    wireMesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true }));
    //mesh.add( wireMesh );
    targetList.push(mesh);
    
}

function onDocumentMouseMove( event ) 
{
    // the following line would stop any other event handler from firing
    // (such as the mouse's TrackballControls)
    //event.preventDefault();
	
    // update the mouse variable
    mouse.x = ( event.clientX / 400 ) * 2 - 1;
    mouse.y = - ( event.clientY / 300 ) * 2 + 1;
}

function onDocumentMouseDown( event ){
	
    console.log("Click.");
    mouse.x = ( event.clientX / 400  ) * 2 - 1;
    mouse.y = - ( event.clientY / 300 ) * 2 + 1;
    
    checkSelection();
 }
/*
function ColorSelected(){
	selectedFaces.forEach( function(arrayItem)
		{
			arrayItem.face.color = selectedColor;
			arrayItem.object.geometry.colorsNeedUpdate = true;
		});
}
*/
function checkSelection(){ 

    //test items in selected faces array
    var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
    projector.unprojectVector( vector, camera );
    var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
    
    intersects = ray.intersectObjects( targetList );
	
    if ( intersects.length > 0 && intersects !== null ){
        
        console.log("Hit @ " + toString( intersects[0].point ) );
		/*
		//test items in selected faces array
		var test=-1; 
		selectedFaces.forEach( function(arrayItem)
		{
			// if the faceIndex and object ID are the same between the intersect and selected faces ,
			// the face index is recorded
			if(intersects[0].faceIndex==arrayItem.faceIndex && intersects[0].object.id==arrayItem.object.id){
				test=selectedFaces.indexOf(arrayItem);
			}
		});
		
		// if is a previously selected face, change the color back to green, otherswise change to blue
		if(test>=0){
			intersects[ 0 ].face.color=new THREE.Color( 0x44dd66 ); 
			selectedFaces.splice(test, 1);
		}
		else{
			intersects[ 0 ].face.color=new THREE.Color( 0x222288 ); 
			selectedFaces.push(intersects[0]);
		}
        */
        intNormal = intersects[0].face.normal;
        
        for(var i=0; i< geometry.faces.length; i++)
        {
            if( Compare(geometry.faces[i].normal, intNormal))
            {
                if(intersects[0].faceIndex !== i)
                indexFaceArr.push(i);
            }
        }
        planeSelect = Plane(intersects[0].face, indexFaceArr);
        planeSelect.push(intersects[0].faceIndex);
        UpdateColor(planeSelect);
    }
}
/*
function checkHighlight(){
	// find intersections

	// create a Ray with origin at the mouse position
	//   and direction into the scene (camera direction)
	var vector = new THREE.Vector3( mouse.x, mouse.y, 1 );
	projector.unprojectVector( vector, camera );
	var ray = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );

	// create an array containing all objects in the scene with which the ray intersects
	var intersects = ray.intersectObjects( targetList );

	// INTERSECTED = the object in the scene currently closest to the camera 
	//		and intersected by the Ray projected from the mouse position 	
	
	// if there is one (or more) intersections
	if ( intersects.length > 0 )
	{	// case if mouse is not currently over an object
		if(INTERSECTED==null){
			INTERSECTED = intersects[ 0 ];
			INTERSECTED.face.color = highlightedColor;
		}
		else{	// if thse mouse is over an object
			INTERSECTED.face.color= baseColor;
			INTERSECTED.object.geometry.colorsNeedUpdate=true;
			INTERSECTED = intersects[ 0 ];
			INTERSECTED.face.color = highlightedColor;			
		}
		// upsdate mouseSphere coordinates and update colors
		mouseSphereCoords = [INTERSECTED.point.x,INTERSECTED.point.y,INTERSECTED.point.z];
		INTERSECTED.object.geometry.colorsNeedUpdate=true;
		
	} 
	else // there are no intersections
	{
		// restore previous intersection object (if it exists) to its original color
		if ( INTERSECTED ){
			INTERSECTED.face.color = baseColor;
			INTERSECTED.object.geometry.colorsNeedUpdate=true;
		}
		// remove previous intersection object reference
		//     by setting current intersection object to "nothing"
		
		INTERSECTED = null;
		mouseSphereCoords = null;
		
		
	}
}

function CheckMouseSphere(){
	// if the coordinates exist, make the sphere visible
	if(mouseSphereCoords != null){
		mouseSphere[0].position.set(mouseSphereCoords[0],mouseSphereCoords[1],mouseSphereCoords[2]);
		mouseSphere[0].visible = true;
	}
	else{ // otherwise hide the sphere
		mouseSphere[0].visible = false;
	}
}
*/
function UpdateColor(indexArr){
    if(indexArr.length > 0){
    	for(var i=0; i< indexArr.length; i++){ 
        	geometry.faces[indexArr[i]].color.setRGB(1,0,0);
    	}
    }
    else{
    	for (var i =0 ; i < geometry.faces.length; i++){
    		geometry.faces[i].color.setRGB(1,1,1);
    	}
    }
    update();
}

function Compare(vec1, vec2){
    if(vec1.x === vec2.x && vec1.y === vec2.y && vec1.z === vec2.z)
        return true;
    else
        return false;
}

function CompareFaces(face1, face2){
    var key = ['a', 'b', 'c'],cnt = 0; 
	for(var i=0; i<3; i++){
		for(var j=0; j< 3; j++){
			if( face1[key[i]] === face2[key[j]] )
				cnt++;
		}
    }
	return cnt;
}

function Plane(intFace, newFaceArr){
    var count = 0;
	var match1V = [], match0V = [];
    for(var n=0; n< newFaceArr.length; n++){
        count = 0;
		count = CompareFaces(intFace, geometry.faces[ newFaceArr[n] ]);
        if(count === 0)
        {
            match0V.push(newFaceArr[n]);
        }
        else if(count > 0)
        {
            match1V.push(newFaceArr[n]);
        }
    }
    //match1V = planeExtrapolate(match1V,match0V);
    return match1V;
}

function planeExtrapolate(match1,match0){
    var i = 0, count2 = 0;
    while(i < match0.length){
    for(var j=0; j< match1.length; j++){
        count2 += CompareFaces( geometry.faces[ match1[j]], geometry.faces[ match0[i]] );
    }
    if( count2 > 0)
    {
        var temp = match0[i];
	match0.splice(i,1);
	match1.push( temp);
    }	
    else
        i++;
    }
    return match1;
}

// Return unique values inside array
Array.prototype.getUnique = function(){
    var u = {}, a = [];
    for (var i = 0, l = this.length; i < l; ++i){
        if (u.hasOwnProperty(this[i])) {  	// hasOwnProperty returns true when there is a property exisitng in the object
            continue;
	}
	a.push(this[i]);
	u[this[i]] = 1;
    }
    return a;
};

function Scale(){
    var Sx = parseFloat(document.getElementById('xscale_value').value);
    var Sy = parseFloat(document.getElementById('yscale_value').value);
    var Sz = parseFloat(document.getElementById('zscale_value').value);
    if (isNaN(Sx)){Sx = 1;} if (isNaN(Sy)){Sy = 1;} if (isNaN(Sz)){Sz = 1;}	
    mesh.scale.set(Sx,Sy,Sz);
}

function Move(){
    var Mx = parseFloat(document.getElementById('xmove_value').value);
    var My = parseFloat(document.getElementById('ymove_value').value);
    var Mz = parseFloat(document.getElementById('zmove_value').value);
    if (isNaN(Mx)){Mx = 0;} if (isNaN(My)){My = 0;} if (isNaN(Mz)){Mz = 0;}	
    mesh.position.x += Mx;
    mesh.position.y += My;
    mesh.position.z += Mz;
}

function Rotate(){
    pi = Math.PI;
    var Ax = pi * (parseFloat(document.getElementById('xrot_value').value) / 180);
    var Ay = pi * (parseFloat(document.getElementById('yrot_value').value) / 180);
    var Az = pi * (parseFloat(document.getElementById('zrot_value').value) / 180);
    if (isNaN(Ax)){Ax = 0;} if (isNaN(Ay)){Ay = 0;} if (isNaN(Az)){Az = 0;}
    mesh.rotation.x += Ax;
    mesh.rotation.y += Ay;
    mesh.rotation.z += Az;
}

function Extrude(){
    if(intersects.length > 0)
    {
        var val = parseFloat(document.getElementById('extrVal').value);
        var vertArr = [];
        for(var i=0; i<planeSelect.length; i++){
            vertArr.push(geometry.faces[planeSelect[i]].a);
            vertArr.push(geometry.faces[planeSelect[i]].b);
            vertArr.push(geometry.faces[planeSelect[i]].c);
        }
        vertArr = vertArr.getUnique();
        vertArr.sort(function(a, b){return a - b});
        for(var i=0; i<vertArr.length; i++){
			geometry.vertices[vertArr[i]].x += val * intNormal.x;
			geometry.vertices[vertArr[i]].y += val * intNormal.y;
			geometry.vertices[vertArr[i]].z += val * intNormal.z;
        }
    }
    else
    {
        alert('Please select a plane!!');
    }
    update(); 
}

function setOrigin(){
	mesh.position.set(0,0,0);
}


function Reset(){
    if(intersects.length > 0){
    	intersects = []; 
    }
    planeSelect = [];
    UpdateColor(planeSelect);
    
    scene.remove(mesh);
    geometry.vertices = geometryOrig.slice(0);
    newMesh(geometry);

}

function render() 
{
    requestAnimationFrame( render );
    renderer.render( scene, camera );		
    update();
}

function update()
{
    geometry.verticesNeedUpdate = true;
    geometry.elementsNeedUpdate = true;
    geometry.colorsNeedUpdate = true;
/*    checkHighlight();
	CheckMouseSphere();
    ColorSelected();
*/    controls.update();
}
function stringifyVertex(vec){
  return "vertex "+vec.x+" "+vec.y+" "+vec.z+" \n";
}
 
// Given a THREE.Geometry, create an STL string
function generateSTL(geo){
  var vertices = geo.vertices;
  var tris     = geo.faces;
 
  var stl = "solid pixel";
  for(var i = 0; i<tris.length; i++){
    stl += ("facet normal "+stringifyVertex( tris[i].normal )+" \n");
    stl += ("outer loop \n");
    stl += stringifyVertex( vertices[ tris[i].a ]);
    stl += stringifyVertex( vertices[ tris[i].b ]);
    stl += stringifyVertex( vertices[ tris[i].c ]);
    stl += ("endloop \n");
    stl += ("endfacet \n");
  }
  stl += ("endsolid");
 
  return stl;
}
 
// Use FileSaver.js 'saveAs' function to save the string
function saveSTL( ){  
  var stlString = generateSTL( geometry );
  
  var blob = new Blob([stlString], {type: 'text/plain'});
  
  saveAs(blob, name + 'CHACHA.stl');
  
}
</script>

</body>
</html>
